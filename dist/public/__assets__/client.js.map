{
  "version": 3,
  "sources": ["../imba/src/imba/scheduler.imba", "../imba/src/imba/dom/flags.imba", "../imba/src/imba/dom/core.web.imba", "../imba/src/imba/dom/fragment.imba", "../imba/src/imba/dom/component.imba", "../imba/src/imba/dom/context.imba", "../imba/src/imba/dom/mount.imba", "client.imba"],
  "sourcesContent": ["# imba$imbaPath=global\nlet rAF = global.requestAnimationFrame || (do(blk) setTimeout(blk,1000 / 60))\nlet FPS = 60\nlet SPF = 1 / 60\n\nlet parseCache = {}\n\ndef parseScheduleValue input\n\tif input === true or input === false or input === null\n\t\treturn input\n\n\tlet v = parseCache[input]\n\treturn v if v !== undefined\n\tlet val = input\n\tif typeof val == 'string'\n\t\tif val.match(/^\\d+fps$/)\n\t\t\tval = 60 / parseInt(val)\n\t\telif val.match(/^[\\d\\.]+s$/)\n\t\t\tval = parseFloat(val) / (1 / 60)\n\t\telif val.match(/^[\\d\\.]+ms$/)\n\t\t\tval = parseFloat(val) / (1000 / 60)\n\treturn parseCache[input] = val\n\t\t\n\n# Scheduler\nclass Scheduled\n\towner = null\n\ttarget = null\n\tactive = no\n\tvalue = undefined\n\tskip = 0\n\tlast = 0\n\n\tdef tick scheduler\n\t\tlast = owner.#frames\n\t\ttarget.tick(owner)\n\n\tdef update o, activate?\n\t\tlet on = active\n\t\tlet val = parseScheduleValue(o.value)\n\n\t\tif value != val\n\t\t\tdeactivate!\n\t\t\tvalue = val\n\n\t\tconsole.log 'update scheduled',value,val,o.value,typeof o.value\n\t\tif value or on or activate?\n\t\t\tactivate!\n\t\tself\n\n\tdef queue\n\t\towner.add(self)\n\t\treturn\n\n\tdef activate\n\t\tif value === yes\n\t\t\towner.on('commit',self)\n\t\telif value === no\n\t\t\t# stop from even \n\t\t\towner.on('commit',self)\n\t\telif value <= 2 and value >= 0.1\n\t\t\towner.on('raf',self)\n\t\telif value > 2\n\t\t\t#interval = global.setInterval(queue.bind(self),value * (1000 / FPS))\n\n\t\tactive = yes\n\t\tself\n\n\tdef deactivate\n\t\tif value === yes\n\t\t\towner.un('commit',self)\n\t\towner.un('raf',self)\n\t\tglobal.clearInterval(#interval)\n\t\tactive = no\n\t\tself\n\nexport class Scheduler\n\tdef constructor\n\t\tid = Symbol!\n\t\tself.queue = []\n\t\tself.stage = -1\n\t\t#stage = -1\n\t\t#frames = 0\n\t\t#scheduled = no\n\t\t\n\t\tself.listeners = {}\n\t\tself.intervals = {}\n\t\tself.commit = do\n\t\t\tadd('commit')\n\t\t\treturn self\n\n\t\t#fps = 0\n\n\t\t$promise = null\n\t\t$resolve = null\n\t\t#ticker = do(e)\n\t\t\t#scheduled = no\n\t\t\tself.tick(e)\n\t\tself\n\n\tdef add item, force\n\t\tif force or self.queue.indexOf(item) == -1\n\t\t\tself.queue.push(item)\n\n\t\t#schedule! unless #scheduled\n\t\treturn self\n\n\tdef listen ns, item\n\t\tlet set = listeners[ns]\n\t\tlet first = !set\n\t\tset ||= listeners[ns] = new Set\n\t\tset.add(item)\n\n\t\tadd('raf') if ns == 'raf' and first\n\t\tself\t\n\n\tdef unlisten ns, item\n\t\tlet set = listeners[ns]\n\t\tset && set.delete(item)\n\t\tif ns == 'raf' and set and set.size == 0\n\t\t\tdelete listeners.raf\n\t\tself\n\n\tdef on ns,item\n\t\tlisten(ns,item)\n\n\tdef un ns,item\n\t\tunlisten(ns,item)\n\n\tget promise\n\t\t$promise ||= new Promise do(resolve)\n\t\t\t$resolve = resolve\n\n\tdef tick timestamp\n\t\tlet items = self.queue\n\t\tlet frame = #frames++\n\t\tself.ts = timestamp unless self.ts\n\t\tself.dt = timestamp - self.ts\n\t\tself.ts = timestamp\n\t\tself.queue = []\n\t\t#stage = 1\n\n\t\t# calculate frames elapsed since last tick etc?\n\n\t\tif items.length\n\t\t\tfor item,i in items\n\t\t\t\tif typeof item === 'string' && listeners[item]\n\t\t\t\t\tlisteners[item].forEach do |item|\n\t\t\t\t\t\tif item.tick isa Function\n\t\t\t\t\t\t\titem.tick(self)\n\t\t\t\t\t\telif item isa Function\n\t\t\t\t\t\t\titem(self)\n\t\t\t\telif item isa Function\n\t\t\t\t\titem(self.dt,self)\n\t\t\t\telif item.tick\n\t\t\t\t\titem.tick(self.dt,self)\n\n\t\t#stage = #scheduled ? 0 : -1\n\n\t\tif $promise\n\t\t\t$resolve(self)\n\t\t\t$promise = $resolve = null\n\n\t\tif listeners.raf and true\n\t\t\tadd('raf')\n\t\tself\n\n\tdef #schedule\n\t\tif !#scheduled\n\t\t\t#scheduled = yes\n\t\t\t#stage = 0 if #stage == -1\n\t\t\trAF(#ticker)\n\t\tself\n\n\tdef schedule item, o\n\t\to ||= (item[id] ||= {value: yes})\n\t\tlet state = o[id] ||= new Scheduled(owner: self, target: item)\n\t\tstate.update(o,yes)\n\n\tdef unschedule item, o = {}\n\t\to ||= item[id]\n\t\tlet state = o and o[id]\n\t\tif state and state.active\n\t\t\tstate.deactivate!\n\t\tself\n\nexport const scheduler = new Scheduler \n\nexport def commit\n\tscheduler.add('commit').promise\n\nexport def setTimeout fn,ms\n\tglobal.setTimeout(&,ms) do\n\t\tfn!\n\t\tcommit!\n\t\treturn\n\nexport def setInterval fn,ms\n\tglobal.setInterval(&,ms) do\n\t\tfn!\n\t\tcommit!\n\t\treturn\n\nexport const clearInterval = global.clearInterval\nexport const clearTimeout = global.clearTimeout", "export class Flags\n\n\tdef constructor dom\n\t\tdom = dom\n\t\tstring = \"\"\n\n\tdef contains ref\n\t\treturn dom.classList.contains(ref)\n\n\tdef add ref\n\t\treturn self if contains(ref)\n\t\tstring += (string ? ' ' : '') + ref\n\t\tdom.classList.add(ref)\n\t\t# sync!\n\t\treturn self\n\n\tdef remove ref\n\t\treturn self unless contains(ref)\n\t\tvar regex = new RegExp('(^|\\\\s)*' + ref + '(\\\\s|$)*', 'g')\n\t\tstring = string.replace(regex, '')\n\t\tdom.classList.remove(ref)\n\t\t# sync!\n\t\treturn self\n\n\tdef toggle ref, bool\n\t\tbool = !contains(ref) if bool === undefined\n\t\tbool ? add(ref) : remove(ref)\n\t\t\n\tdef incr ref\n\t\tlet m = stacks ||= {}\n\t\tlet c = m[ref] or 0\n\t\tadd(ref) if c < 1\n\t\tm[ref] = Math.max(c,0) + 1\n\t\treturn self\n\t\n\tdef decr ref\n\t\tlet m = stacks ||= {}\n\t\tlet c = m[ref] or 0\n\t\tremove(ref) if c == 1\n\t\tm[ref] = Math.max(c,1) - 1\n\t\treturn self\n\n\tdef valueOf\n\t\tstring\n\n\tdef toString\n\t\tstring\n\n\tdef sync\n\t\tdom.flagSync$!", "import {Flags} from './flags'\n\nexport const {\n\tEvent,\n\tUIEvent,\n\tMouseEvent,\n\tPointerEvent,\n\tKeyboardEvent,\n\tCustomEvent,\n\tNode,\n\tComment,\n\tText,\n\tElement,\n\tHTMLElement,\n\tHTMLHtmlElement,\n\tHTMLSelectElement,\n\tHTMLInputElement,\n\tHTMLTextAreaElement,\n\tHTMLButtonElement,\n\tHTMLOptionElement,\n\tHTMLScriptElement,\n\tSVGElement,\n\tDocumentFragment,\n\tShadowRoot,\n\tDocument,\n\tWindow,\n\tcustomElements\n} = global.window\n\n# export const document = global.window.document\nconst CustomTagConstructors = {}\nconst CustomTagToElementNames = {}\nexport const TYPES = {}\nexport const CUSTOM_TYPES = {}\nexport def get_document\n\tglobal.document\n\nexport def use_window\n\tyes\n\n\n\n# Basic node extensions\n\nconst contextHandler =\n\tdef get target, name\n\t\tlet ctx = target\n\t\tlet val = undefined\n\t\twhile ctx and val == undefined\n\t\t\tif ctx = ctx.#parent\n\t\t\t\tval = ctx[name]\n\t\treturn val\n\nextend class Node\n\tget #parent\n\t\t##parent or this.parentNode or ##up # FIX\n\n\tget #context\n\t\t##context ||= new Proxy(self,contextHandler)\n\n\tdef #init\n\t\tself\n\n\t# replace this with something else\n\tdef replaceWith$ other\n\t\tif !(other isa Node) and other.replace$\n\t\t\tother.replace$(this)\n\t\telse\n\t\t\tself.parentNode.replaceChild(other,this)\n\t\treturn other\n\n\tdef insertInto$ parent\n\t\tparent.appendChild$(this)\n\t\treturn this\n\n\tdef insertBefore$ el, prev\n\t\tthis.insertBefore(el,prev)\n\n\tdef insertBeforeBegin$ other\n\t\tself.parentNode.insertBefore(other,this)\n\n\tdef insertAfterEnd$ other\n\t\tif self.nextSibling\n\t\t\tself.nextSibling.insertBeforeBegin$(other)\n\t\telse\n\t\t\tself.parentNode.appendChild(other)\n\t\n\tdef insertAfterBegin$ other\n\t\tif self.childNodes[0]\n\t\t\tself.childNodes[0].insertBeforeBegin$(other)\n\t\telse\n\t\t\tself.appendChild(other)\n\n# Basic element extensions\nextend class Element\n\t\n\tdef log ...params\n\t\tconsole.log(...params)\n\t\tself\n\n\tdef slot$ name, ctx\n\t\treturn self\n\n\t# inline in files or remove all together?\n\tdef text$ item\n\t\tself.textContent = item\n\t\tself\n\n\tdef insert$ item, f, prev\n\t\tlet type = typeof item\n\n\t\tif type === 'undefined' or item === null\n\t\t\t# what if the prev value was the same?\n\t\t\tif prev and prev isa Comment # check perf\n\t\t\t\treturn prev\n\n\t\t\tlet el = document.createComment('')\n\t\t\tprev ? prev.replaceWith$(el) : el.insertInto$(this)\n\t\t\treturn el\n\n\t\t# dont reinsert again\n\t\tif item === prev\n\t\t\treturn item\n\n\t\t# what if this is null or undefined -- add comment and return? Or blank text node?\n\t\telif type !== 'object'\n\t\t\tlet res\n\t\t\tlet txt = item\n\t\t\t\n\t\t\tif (f & $TAG_FIRST_CHILD$) && (f & $TAG_LAST_CHILD$)\n\t\t\t\t# FIXME what if the previous one was not text? Possibly dangerous\n\t\t\t\t# when we set this on a fragment - it essentially replaces the whole\n\t\t\t\t# fragment?\n\t\t\t\tself.textContent = txt\n\t\t\t\treturn\n\n\t\t\tif prev\n\t\t\t\tif prev isa Text # check perf\n\t\t\t\t\tprev.textContent = txt\n\t\t\t\t\treturn prev\n\t\t\t\telse\n\t\t\t\t\tres = document.createTextNode(txt)\n\t\t\t\t\tprev.replaceWith$(res,self)\n\t\t\t\t\treturn res\n\t\t\telse\n\t\t\t\tself.appendChild$(res = document.createTextNode(txt))\n\t\t\t\treturn res\t\n\n\t\telse\n\t\t\tprev ? prev.replaceWith$(item,self) : item.insertInto$(self)\n\t\t\treturn item\n\t\treturn\n\n\tdef open$\n\t\tself\n\n\tdef close$\n\t\tself\n\n\tdef end$\n\t\tself.render() if self.render\n\t\treturn\n\n\tget flags\n\t\tunless $flags\n\t\t\t# unless deopted - we want to first cache the extflags\n\t\t\t$flags = new Flags(self)\n\t\t\tif flag$ == Element.prototype.flag$\n\t\t\t\tflags$ext = self.className\n\t\t\tflagDeopt$()\n\t\treturn $flags\n\n\tdef flag$ str\n\t\t# Potentially slow\n\t\tlet ns = flags$ns\n\t\tself.className = ns ? (ns + (flags$ext = str)) : (flags$ext = str)\n\t\treturn\n\t\t\n\tdef flagDeopt$\n\t\tself.flag$ = self.flagExt$ # do(str) self.flagSync$(flags$ext = str)\n\t\tself.flagSelf$ = do(str) self.flagSync$(flags$own = str)\n\t\treturn\n\t\t\n\tdef flagExt$ str\n\t\tself.flagSync$(flags$ext = str)\n\n\tdef flagSelf$ str\n\t\t# if a tag receives flags from inside <self> we need to\n\t\t# redefine the flag-methods to later use both\n\t\tflagDeopt$()\n\t\treturn flagSelf$(str)\n\n\tdef flagSync$\n\t\tself.className = ((flags$ns or '') + (flags$ext or '') + ' ' + (flags$own || '') + ' ' + ($flags or ''))\n\n\nElement.prototype.appendChild$  = Element.prototype.appendChild\nElement.prototype.removeChild$  = Element.prototype.removeChild\nElement.prototype.insertBefore$ = Element.prototype.insertBefore\nElement.prototype.replaceChild$ = Element.prototype.replaceChild\nElement.prototype.set$ = Element.prototype.setAttribute\nElement.prototype.setns$ = Element.prototype.setAttributeNS\n\nexport def createElement name, parent, flags, text\n\tlet el = document.createElement(name)\n\t\t\n\tel.className = flags if flags\n\n\tif text !== null\n\t\tel.text$(text)\n\n\tif parent and parent isa Node\n\t\tel.insertInto$(parent)\n\n\treturn el\n\n\nconst descriptorCache = {}\ndef getDescriptor item,key,cache\n\tif !item\n\t\treturn cache[key] = null\n\n\tif cache[key] !== undefined\n\t\treturn cache[key]\n\t\n\tlet desc = Object.getOwnPropertyDescriptor(item,key)\n\n\tif desc !== undefined or item == SVGElement\n\t\treturn cache[key] = desc or null\n\n\tgetDescriptor(Reflect.getPrototypeOf(item),key,cache)\n\nextend class SVGElement\n\n\tdef set$ key,value\n\t\tlet cache = descriptorCache[nodeName] ||= {}\n\t\tlet desc = getDescriptor(this,key,cache)\n\n\t\tif !desc or !desc.set\n\t\t\tsetAttribute(key,value)\n\t\telse\n\t\t\tself[key] = value\n\t\treturn\n\n\tdef flag$ str\n\t\tlet ns = flags$ns\n\t\tself.className.baseVal = ns ? (ns + (flags$ext = str)) : (flags$ext = str)\n\t\treturn\n\n\tdef flagSelf$ str\n\t\t# if a tag receives flags from inside <self> we need to\n\t\t# redefine the flag-methods to later use both\n\t\tself.flag$ = do(str) self.flagSync$(flags$ext = str)\n\t\tself.flagSelf$ = do(str) self.flagSync$(flags$own = str)\n\t\treturn flagSelf$(str)\n\n\tdef flagSync$\n\t\tself.className.baseVal = ((flags$ns or '') + (flags$ext or '') + ' ' + (flags$own || '') + ' ' + ($flags or ''))\n\n\nextend class SVGSVGElement\n\n\tset src value\n\t\tif #src =? value\n\t\t\tif value..adoptNode\n\t\t\t\tvalue.adoptNode(self)\n\t\t\telif value..content\n\t\t\t\tfor own k,v of value.attributes\n\t\t\t\t\tsetAttribute(k,v)\n\t\t\t\tinnerHTML = value.content\n\t\treturn\n\n\t\t\n\nexport def createSVGElement name, parent, flags, text, ctx\n\tlet el = document.createElementNS(\"http://www.w3.org/2000/svg\",name)\n\n\tif flags\n\t\tel.className.baseVal = flags\n\n\tif parent and parent isa Node\n\t\tel.insertInto$(parent)\n\treturn el\n\nexport def createComment text\n\tdocument.createComment(text)\n\nexport def createFragment\n\tdocument.createDocumentFragment!\n\n\n\nconst vendor = global.navigator..vendor or ''\nconst ua = global.navigator..userAgent or ''\n\nconst isSafari = vendor.indexOf('Apple') > -1 || ua.indexOf('CriOS') >= 0 || ua.indexOf('FxiOS') >= 0\nconst supportsCustomizedBuiltInElements = !isSafari\nconst CustomDescriptorCache = new Map\n\nclass CustomHook < HTMLElement\n\tdef connectedCallback\n\t\tif supportsCustomizedBuiltInElements\n\t\t\tparentNode.removeChild(self)\n\t\telse\n\t\t\tparentNode.connectedCallback!\n\n\tdef disconnectedCallback\n\t\tif !supportsCustomizedBuiltInElements\n\t\t\tparentNode.disconnectedCallback!\n\nwindow.customElements.define('i-hook',CustomHook)\n\ndef getCustomDescriptors el, klass\n\tlet props = CustomDescriptorCache.get(klass)\n\n\tunless props\n\t\tprops = {}\n\t\tlet proto = klass.prototype\n\t\tlet protos = [proto]\n\t\twhile proto = (proto and Object.getPrototypeOf(proto))\n\t\t\tbreak if proto.constructor == el.constructor\n\t\t\tprotos.unshift(proto)\n\n\t\tfor item in protos\n\t\t\tlet desc = Object.getOwnPropertyDescriptors(item)\n\t\t\tObject.assign(props,desc)\n\t\tCustomDescriptorCache.set(klass,props)\n\n\treturn props\n\n# Registry\nexport def createComponent name, parent, flags, text, ctx\n\t# the component could have a different web-components name?\n\tlet el\n\t\n\tif typeof name != 'string'\n\t\tif name and name.nodeName\n\t\t\tname = name.nodeName\n\n\tlet cmpname = CustomTagToElementNames[name] or name\n\n\tif CustomTagConstructors[name]\n\t\tlet cls = CustomTagConstructors[name]\n\t\tlet typ = cls.prototype.#htmlNodeName\n\t\tif typ and supportsCustomizedBuiltInElements\n\t\t\tel = document.createElement(typ,is: name)\n\t\telif cls.create$ and typ\n\t\t\tel = document.createElement(typ)\n\t\t\tel.setAttribute('is',cmpname)\n\t\t\tlet props = getCustomDescriptors(el,cls)\n\t\t\tObject.defineProperties(el,props)\n\t\t\tel.__slots = {}\n\t\t\t# check if we need a hook though?\n\t\t\tel.appendChild(document.createElement('i-hook'))\n\t\telif cls.create$\n\t\t\tel = cls.create$(el)\n\t\t\tel.__slots = {}\n\t\telse\n\t\t\tconsole.warn \"could not create tag {name}\"\n\telse\n\t\tel = document.createElement(CustomTagToElementNames[name] or name)\n\n\tel.##parent = parent\n\tel.#init!\n\n\tif text !== null\n\t\tel.slot$('__').text$(text)\n\t\t\n\tif flags or el.flags$ns # or nsflag\n\t\tel.flag$(flags or '')\n\treturn el\n\nexport def getTagType name, klass\n\t# TODO follow same structure as ssr TYPES\n\tif TYPES[name]\n\t\treturn TYPES[name]\n\n\tif window[klass]\n\t\treturn window[klass]\n\n\tif window[name]\n\t\treturn window[name]\n\nexport def getSuperTagType name, klass, cmp\n\tlet typ = getTagType(name,klass)\n\tlet custom = typ == cmp or typ.prototype isa cmp or typ.prototype.#htmlNodeName\n\n\tif !custom\n\t\tlet cls = typ.prototype.#ImbaElement\n\n\t\tif !cls\n\t\t\tcls = class CustomBuiltInElement < typ\n\t\t\t\tdef constructor\n\t\t\t\t\tsuper\n\t\t\t\t\t__slots = {}\n\t\t\t\t\t__F = 0\n\n\t\t\ttyp.prototype.#ImbaElement = cls\n\t\t\tlet descriptors = Object.getOwnPropertyDescriptors(cmp.prototype)\n\t\t\tObject.defineProperties(cls.prototype,descriptors)\n\t\t\tcls.prototype.#htmlNodeName = name\n\n\t\treturn cls\n\n\treturn typ\n\nexport def defineTag name, klass, options = {}\n\tTYPES[name] = CUSTOM_TYPES[name] = klass\n\n\tklass.nodeName = name\n\n\tlet componentName = name\n\tlet proto = klass.prototype\n\n\tif name.indexOf('-') == -1\n\t\tcomponentName = \"{name}-tag\"\n\t\tCustomTagToElementNames[name] = componentName\n\n\tlet basens = proto._ns_\n\tif options.ns\n\t\tlet ns = options.ns\n\t\tlet flags = ns + ' ' + ns + '_ '\n\t\tif basens\n\t\t\tflags += proto.flags$ns \n\t\t\tns += ' ' + basens\n\t\tproto._ns_ = ns\n\t\tproto.flags$ns = flags\n\n\tif proto.#htmlNodeName\n\t\toptions.extends = proto.#htmlNodeName\n\n\tif options.extends\n\t\tproto.#htmlNodeName = options.extends\n\t\tCustomTagConstructors[name] = klass\n\n\t\tif supportsCustomizedBuiltInElements\n\t\t\twindow.customElements.define(componentName,klass,extends: options.extends)\n\telse\n\t\twindow.customElements.define(componentName,klass)\n\n\treturn klass", "import {Element,Text,DocumentFragment,createFragment,createComment} from './core'\n\nextend class DocumentFragment\n\n\tget #parent\n\t\t##up or ##parent\n\n\t# Called to make a documentFragment become a live fragment\n\tdef setup$ flags, options\n\t\t$start = createComment('start')\n\t\t$end = createComment('end')\n\n\t\t$end.replaceWith$ = do(other)\n\t\t\tthis.parentNode.insertBefore(other,this)\n\t\t\treturn other\n\n\t\tthis.appendChild($start)\n\t\tthis.appendChild($end)\n\t\n\t# when we for sure know that the only content should be\n\t# a single text node\n\tdef text$ item\n\t\tunless $text\n\t\t\t$text = this.insert$(item)\n\t\telse\n\t\t\t$text.textContent = item\n\t\treturn\n\t\n\tdef insert$ item, options, toReplace\n\t\tif ##parent\n\t\t\t# if the fragment is attached to a parent\n\t\t\t# we can just proxy the call through\n\t\t\t##parent.insert$(item,options,toReplace or $end)\n\t\telse\n\t\t\tElement.prototype.insert$.call(this,item,options,toReplace or $end)\n\n\tdef insertInto$ parent, before\n\t\tunless ##parent\n\t\t\t##parent = parent\n\t\t\t# console.log 'insertFrgment into',parent,Array.from(self.childNodes)\n\t\t\tparent.appendChild$(this)\n\t\treturn this\n\n\tdef replaceWith$ other, parent\n\t\t$start.insertBeforeBegin$(other)\n\t\tvar el = $start\n\t\twhile el\n\t\t\tlet next = el.nextSibling\n\t\t\tself.appendChild(el)\n\t\t\tbreak if el == $end\n\t\t\tel = next\n\t\t\t\n\t\treturn other\n\n\tdef appendChild$ child\n\t\t$end ? $end.insertBeforeBegin$(child) : self.appendChild(child)\n\t\treturn child\n\n\tdef removeChild$ child\n\t\tchild.parentNode && child.parentNode.removeChild(child)\n\t\tself\n\n\tdef isEmpty$\n\t\tlet el = $start\n\t\tlet end = $end\n\n\t\twhile el = el.nextSibling\n\t\t\tbreak if el == end\n\t\t\treturn false if el isa Element or el isa Text\n\t\treturn true\n\nclass VirtualFragment\n\tdef constructor f, parent\n\t\t__F = f\n\t\t#parent = parent\n\n\tdef appendChild$ item, index\n\t\t# we know that these items are dom elements\n\t\tif $end and #parent\n\t\t\t$end.insertBeforeBegin$(item)\n\t\telif #parent\n\t\t\t#parent.appendChild$(item)\n\t\treturn\n\n\tdef replaceWith$ other\n\t\tself.detachNodes()\n\t\t$end.insertBeforeBegin$(other)\n\t\t#parent.removeChild$($end)\n\t\t#parent = null\n\t\treturn\n\n\tdef joinBefore$ before\n\t\tself.insertInto$(before.parentNode,before)\n\n\tdef insertInto$ parent, before\n\t\tunless #parent\n\t\t\t#parent = parent\n\t\t\tbefore ? before.insertBeforeBegin$($end) : parent.appendChild$($end)\n\t\t\tself.attachNodes()\n\t\treturn this\n\t\n\tdef replace$ other\n\t\tunless #parent\n\t\t\t#parent = other.parentNode\n\t\tother.replaceWith$($end)\n\t\tself.attachNodes()\n\t\tself\n\t\t\n\tdef setup\n\t\tself\n\nclass KeyedTagFragment < VirtualFragment\n\t\n\tdef constructor f, parent\n\t\tsuper\n\n\t\tif !(f & $TAG_FIRST_CHILD$)\n\t\t\t$start = createComment('start')\n\t\t\tparent.appendChild$($start) if parent\n\n\t\tunless f & $TAG_LAST_CHILD$\n\t\t\t$end = createComment('end')\n\t\t\tparent.appendChild$($end) if parent\n\n\t\tself.setup()\n\n\tdef setup\n\t\tself.array = []\n\t\tself.changes = new Map\n\t\tself.dirty = no\n\t\tself.$ = {}\n\n\tdef push item, idx\n\t\t# on first iteration we can merely run through\n\t\tunless __F & $TAG_INITED$\n\t\t\tself.array.push(item)\n\t\t\tself.appendChild$(item)\n\t\t\treturn\n\n\t\tlet toReplace = self.array[idx]\n\n\t\tif toReplace === item\n\t\t\tyes\n\t\telse\n\t\t\tself.dirty = yes\n\t\t\t# if this is a new item\n\t\t\tlet prevIndex = self.array.indexOf(item)\n\t\t\tlet changed = self.changes.get(item)\n\n\t\t\tif prevIndex === -1\n\t\t\t\t# should we mark the one currently in slot as removed?\n\t\t\t\tself.array.splice(idx,0,item)\n\t\t\t\tself.insertChild(item,idx)\n\n\t\t\telif prevIndex === idx + 1\n\t\t\t\tif toReplace\n\t\t\t\t\tself.changes.set(toReplace,-1)\n\t\t\t\tself.array.splice(idx,1)\n\n\t\t\telse\n\t\t\t\tself.array.splice(prevIndex,1) if prevIndex >= 0\n\t\t\t\tself.array.splice(idx,0,item)\n\t\t\t\tself.insertChild(item,idx)\n\n\t\t\tif changed == -1\n\t\t\t\tself.changes.delete(item)\n\t\treturn\n\n\tdef insertChild item, index\n\t\tif index > 0\n\t\t\tlet other = self.array[index - 1]\n\t\t\t# will fail with text nodes\n\t\t\tother.insertAfterEnd$(item)\n\t\telif $start\n\t\t\t$start.insertAfterEnd$(item)\n\t\telse\n\t\t\t#parent.insertAfterBegin$(item)\n\t\treturn\n\n\tdef removeChild item, index\n\t\t# self.map.delete(item)\n\t\t# what if this is a fragment or virtual node?\n\t\tif item.parentNode == #parent\n\t\t\t#parent.removeChild(item)\n\t\treturn\n\n\tdef attachNodes\n\t\tfor item,i in self.array\n\t\t\t$end.insertBeforeBegin$(item)\n\t\treturn\n\n\tdef detachNodes\n\t\tfor item in self.array\n\t\t\t#parent.removeChild(item)\n\t\treturn\n\n\tdef end$ index\n\t\tunless __F & $TAG_INITED$\n\t\t\t__F |= $TAG_INITED$\n\t\t\treturn\n\n\t\tif self.dirty\n\t\t\tself.changes.forEach do |pos,item|\n\t\t\t\tif pos == -1\n\t\t\t\t\tself.removeChild(item)\n\t\t\tself.changes.clear()\n\t\t\tself.dirty = no\n\n\t\t# there are some items we should remove now\n\t\tif self.array.length > index\n\t\t\t\n\t\t\t# remove the children below\n\t\t\twhile self.array.length > index\n\t\t\t\tlet item = self.array.pop()\n\t\t\t\tself.removeChild(item)\n\t\t\t# self.array.length = index\n\t\treturn\n\nclass IndexedTagFragment < VirtualFragment\n\n\tdef constructor f, parent\n\t\tsuper\n\n\t\tunless f & $TAG_LAST_CHILD$\n\t\t\t$end = createComment('end')\n\t\t\tparent.appendChild$($end) if parent\n\n\t\tself.setup()\n\n\tdef setup\n\t\tself.$ = []\n\t\tself.length = 0\n\n\tdef end$ len\n\t\tlet from = self.length\n\t\treturn if from == len or !#parent\n\t\tlet array = self.$\n\t\tlet par = #parent\n\n\t\tif from > len\n\t\t\twhile from > len\n\t\t\t\tpar.removeChild$(array[--from])\n\t\telif len > from\n\t\t\twhile len > from\n\t\t\t\tself.appendChild$(array[from++])\n\t\tself.length = len\n\t\treturn\n\n\tdef attachNodes\n\t\tfor item,i in self.$\n\t\t\tbreak if i == self.length\n\t\t\t$end.insertBeforeBegin$(item)\n\t\treturn\n\n\tdef detachNodes\n\t\tlet i = 0\n\t\twhile i < self.length\n\t\t\tlet item = self.$[i++]\n\t\t\t#parent.removeChild$(item)\n\t\treturn\n\nexport def createLiveFragment bitflags, options, par\n\tconst el = createFragment!\n\tel.setup$(bitflags, options)\n\tel.##up = par if par\n\treturn el\n\nexport def createIndexedFragment bitflags, parent\n\treturn new IndexedTagFragment(bitflags,parent)\n\nexport def createKeyedFragment bitflags, parent\n\treturn new KeyedTagFragment(bitflags,parent)\n\n\n", "import {Node,HTMLElement,CUSTOM_TYPES} from './core'\nimport {createLiveFragment} from './fragment'\nimport {scheduler} from '../scheduler'\n\nconst hydrator = new class\n\titems = []\n\tcurrent = null\n\tlastQueued = null\n\ttests = 0\n\n\tdef flush\n\t\tlet item = null\n\n\t\tif false\n\t\t\tconsole.log 'flush hydrate',items,tests\n\t\t\tfor item,i in items\n\t\t\t\tlet next = items[i + 1]\n\t\t\t\tif next\n\t\t\t\t\tunless next.compareDocumentPosition(item) & Node.DOCUMENT_POSITION_PRECEDING\n\t\t\t\t\t\tconsole.log \"WRONG ORDER!!!\",item,next,next.compareDocumentPosition(item)\n\n\t\twhile item = items.shift!\n\t\t\tcontinue if !item.parentNode or item.hydrated?\n\t\t\t# Mark as inited to stop connectedCallback from early exit\n\t\t\tlet prev = current\n\t\t\tcurrent = item\n\t\t\titem.__F |= $EL_SSR$\n\t\t\titem.connectedCallback!\n\t\t\tcurrent = prev\n\t\treturn\n\n\tdef queue item\n\t\t# let len = items.push(item)\n\t\tlet len = items.length\n\t\tlet idx = 0\n\t\tlet prev = lastQueued\n\t\tlastQueued = item\n\n\t\tlet BEFORE = Node.DOCUMENT_POSITION_PRECEDING\n\t\tlet AFTER = Node.DOCUMENT_POSITION_FOLLOWING\n\n\t\tif len\n\t\t\tlet prevIndex = items.indexOf(prev)\n\t\t\tlet index = prevIndex\n\n\t\t\tlet compare = do(a,b)\n\t\t\t\ttests++\n\t\t\t\ta.compareDocumentPosition(b)\n\n\t\t\tif prevIndex == -1 or prev.nodeName != item.nodeName\n\t\t\t\tindex = prevIndex = 0\n\n\t\t\tlet curr = items[index]\n\n\t\t\twhile curr and compare(curr,item) & AFTER\n\t\t\t\tcurr = items[++index]\n\n\t\t\tif index != prevIndex\n\t\t\t\tcurr ? items.splice(index,0,item) : items.push(item)\n\t\t\telse\n\t\t\t\twhile curr and compare(curr,item) & BEFORE\n\t\t\t\t\tcurr = items[--index]\n\t\t\t\tif index != prevIndex\n\t\t\t\t\tcurr ? items.splice(index + 1,0,item) : items.unshift(item)\n\t\telse\n\t\t\titems.push(item)\n\t\t\tglobal.queueMicrotask(flush.bind(self)) if !current\n\n\t\treturn\n\n\tdef run item\n\t\treturn if active\n\t\t# look for parents that are still hydrated\n\t\t# only the ssr elements that are not yet awakened\n\t\tactive = yes\n\t\t# let all = global.document.getElementsByClassName('__ssr')\n\t\tlet all = global.document.querySelectorAll('.__ssr')\n\t\tconsole.log 'running hydrator',item,all.length,Array.from(all)\n\n\t\tfor item in all\n\t\t\titem.#count ||= 1\n\t\t\titem.#count++\n\t\t\tlet name = item.nodeName\n\t\t\tlet typ = map[name] ||= global.window.customElements.get(name.toLowerCase!) or HTMLElement\n\t\t\tconsole.log 'item type',name,typ,!!CUSTOM_TYPES[name.toLowerCase!]\n\t\t\t# console.log 'hydrate??',item.constructor\n\t\t\tcontinue if !item.connectedCallback or !item.parentNode or item.hydrated?\n\t\t\tconsole.log 'hydrate',item # !!item.parentNode,item,item.connectedCallback\n\t\t\t# item.connectedCallback!\n\n\t\tactive = no\n\nexport def hydrate\n\thydrator.flush!\n\nexport class ImbaElement < HTMLElement\n\tdef constructor\n\t\tsuper()\n\t\tif flags$ns\n\t\t\t# explain?\n\t\t\tflag$ = flagExt$\n\n\t\tsetup$()\n\t\tbuild()\n\n\tdef setup$\n\t\t__slots = {}\n\t\t__F = 0\n\n\tdef #init\n\t\t__F |= ($EL_INITED$ | $EL_HYDRATED$)\n\t\tself\n\t\t\n\tdef flag$ str\n\n\t\tself.className = flags$ext = str\n\t\treturn\n\n\t# returns the named slot - for context\n\tdef slot$ name, ctx\n\t\tif name == '__' and !render\n\t\t\treturn self\n\n\t\t__slots[name] ||= createLiveFragment(0,null,self)\n\n\t# called immediately after construction \n\tdef build\n\t\tself\n\n\t# called before the first mount\n\tdef awaken\n\t\tself\n\t\n\t# called when element is attached to document\n\tdef mount\n\t\tself\n\n\tdef unmount\n\t\tself\n\n\t# called after render\n\tdef rendered\n\t\tself\n\n\t# called before element is stringified on server (SSR)\n\tdef dehydrate\n\t\tself\n\n\t# called before awaken if element was not initially created via imba - on the client\n\tdef hydrate\n\t\t# should only autoschedule if we are not awakening inside a parent context that\n\t\tautoschedule = yes\n\t\tself\n\n\tdef tick\n\t\tcommit()\n\n\t# called when component is (re-)rendered from its parent\n\tdef visit\n\t\tcommit()\n\n\t# Wrapper for rendering. Default implementation\n\tdef commit\n\t\treturn self unless render?\n\t\t__F |= $EL_RENDERING$\n\t\trender && render()\n\t\trendered()\n\t\t__F = (__F | $EL_RENDERED$) & ~$EL_RENDERING$\n\n\tget autoschedule\n\t\t(__F & $EL_SCHEDULE$) != 0\n\t\n\tset autoschedule value\n\t\tvalue ? (__F |= $EL_SCHEDULE$) : (__F &= ~$EL_SCHEDULE$)\n\n\t###\n\tyes = render on events / imba.commit\n\tno = don't even render when parent is rendered\n\t1s = render every 1 second\n\t30fps = render 30 times per second\n\t###\n\tset autorender value\n\t\tlet o = #autorender ||= {}\n\t\to.value = value\n\t\tscheduler.schedule(self,o) if mounted?\n\t\treturn\n\n\tget render?\n\t\treturn true\n\n\tget mounting?\n\t\treturn (__F & $EL_MOUNTING$) != 0\n\n\tget mounted?\n\t\treturn (__F & $EL_MOUNTED$) != 0\n\t\n\tget awakened?\n\t\treturn (__F & $EL_AWAKENED$) != 0\n\t\n\tget rendered?\n\t\treturn (__F & $EL_RENDERED$) != 0\n\n\tget rendering?\n\t\treturn (__F & $EL_RENDERING$) != 0\n\t\n\tget scheduled?\n\t\treturn (__F & $EL_SCHEDULED$) != 0\n\n\tget hydrated?\n\t\treturn (__F & $EL_HYDRATED$) != 0\n\n\tget ssr?\n\t\treturn (__F & $EL_SSR$) != 0\n\n\tdef schedule\n\t\tscheduler.on('commit',self)\n\t\t__F |= $EL_SCHEDULED$\n\t\treturn self\n\n\tdef unschedule\n\t\tscheduler.un('commit',self)\n\t\t__F &= ~$EL_SCHEDULED$\n\t\treturn self\n\n\tdef end$\n\t\tvisit()\n\n\tdef open$\n\t\tif __F & $EL_SSR$\n\t\t\t__F = __F & ~$EL_SSR$\n\t\t\t# remove flag\n\t\t\tclassList.remove('_ssr_')\n\t\t\tif flags$ext and flags$ext.indexOf('_ssr_') == 0\n\t\t\t\tflags$ext = flags$ext.slice(5)\n\t\t\tinnerHTML = ''\n\t\tself\n\n\tdef connectedCallback\n\t\tlet flags = __F\n\t\tlet inited = flags & $EL_INITED$\n\t\tlet awakened = flags & $EL_AWAKENED$\n\n\t\tif !inited and !(flags & $EL_SSR$)\n\t\t\thydrator.queue(self)\n\t\t\treturn\n\n\t\t# return if we are already in the process of mounting - or have mounted\n\t\tif flags & ($EL_MOUNTING$ | $EL_MOUNTED$)\n\t\t\treturn\n\t\t\n\t\t__F |= $EL_MOUNTING$\n\n\t\tunless inited\n\t\t\t#init!\n\n\t\tunless flags & $EL_HYDRATED$\n\t\t\t# clearly seems wrong?\n\t\t\tflags$ext = className\n\t\t\t__F |= $EL_HYDRATED$\n\t\t\tself.hydrate()\n\t\t\tcommit()\n\n\t\tunless awakened\n\t\t\tawaken()\n\t\t\t__F |= $EL_AWAKENED$\n\n\t\tlet res = mount()\n\t\tif res && res.then isa Function\n\t\t\tres.then(scheduler.commit)\n\n\t\tflags = __F = (__F | $EL_MOUNTED$) & ~$EL_MOUNTING$\n\t\t\n\t\tif flags & $EL_SCHEDULE$\n\t\t\tschedule()\n\t\t\n\t\t\n\t\tscheduler.schedule(self,#autorender) if #autorender\n\t\treturn this\n\n\tdef disconnectedCallback\n\t\t__F = __F & (~$EL_MOUNTED$ & ~$EL_MOUNTING$)\n\t\tif __F & $EL_SCHEDULED$\n\t\t\t# trigger potential unschedule listeners\n\t\t\tunschedule()\n\n\t\tunmount()\n\t\tscheduler.unschedule(self,#autorender) if #autorender", "export const renderContext = {\n\tcontext: null\n}", "import {renderContext} from './context'\nimport {scheduler} from '../scheduler'\n\nexport def mount mountable, into\n\tlet parent = into or global.document.body\n\tlet element = mountable\n\tif mountable isa Function\n\t\tlet ctx = {_: parent}\n\t\tlet tick = do\n\t\t\trenderContext.context = ctx\n\t\t\tmountable(ctx)\n\t\t\t# now remove the context?\n\t\telement = tick()\n\t\tscheduler.listen('commit',tick)\n\telse\n\t\t# automatic scheduling of element - even before\n\t\t# element.__schedule = yes\n\t\telement.__F |= $EL_SCHEDULE$\n\n\tparent.appendChild(element)", "tag App\n\tcss c:red8\n\t\n\t<self> \"Hello world\"\n\nimba.mount <App>\n"],
  "mappings": "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",
  "names": []
}
